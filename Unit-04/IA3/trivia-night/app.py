# --- Import Libraries --- #
# Flask Libraries (used to run the actual website)
from flask import Flask, render_template, request, redirect, flash, session, url_for  # General Flask
from flask_wtf import FlaskForm  # For Flask forms
from flask_bcrypt import Bcrypt  # For encryption
# WTForms Libraries (used for the websites forms)
from wtforms import StringField, SelectField, DateTimeLocalField, SelectMultipleField, SubmitField, EmailField, \
    PasswordField, validators
# Miscellaneous Libraries
import sqlite3  # To connect and run query's for the database
import requests  # To request and download data from APIs
import json  # Required to be able to view and manage the json files and format
from apscheduler.schedulers.background import \
    BackgroundScheduler  # Used to run the get data and clear data functions every 30 minutes
import atexit  # Used for scheduler to shut down the schedules when the app is exited
from datetime import datetime # For getting the current or future datetime


# TODO
#   Emails will be captured however they ill not be displayed on the website for security reasons and in hash format
#   Should add more gamify experiences such as animations, big font, answer streaks and quick play games to pass time
#   Talk about javascript isn't a great method and that I have coded up two other working better solutions however I
#   didn't get a chance to fully implement either of them. Talk about their pros and cons
#   Talk about how it is new for me to use javascript for requests and having an inbuilt post and get api inside flask
#   Talk about how the javascript api request will reach limit quick if users on same public ip
#   Talk about enhanced security via https and blah blah blah
#   Add better password complexity check
#   Add better database security
#   Talk about the changes I made below:
#   I have bcrypt running encryption and have a salt generated 17 time for maximum obfuscation while still
#   keeping performance
#   If I make the requests within javascript the client would be calling the API meaning the server side doesnt have to
#   -worry about request limits although if the user is technical they could dig up the answers although I can make this
#   -really hard to do
#   Mention that I'm using code from IA2
#   Daily quiz is handled by flask with an javascript countdown
#   Quizzes are generated by javascript but is handed get info and users completed questions
#   The quizzes are entirely generated by javascript?
#   What if the API doesn't respond set a fallback option or error message to retry
#   Daily question was disabled
#   Leaderboard is not set
#   LOAD THE QUESTIONS BEFOREHAND AND DISTRIBUTE THEM OR USE JAVASCRIPT?


# --- Assign flask app --- #
app = Flask(__name__)


# --- Assign Bcrypt --- #
bcrypt = Bcrypt(app)
bcrypt_level = 19  # The rounds of salt generation Bcrypt will run per encryption (This increases tha passwords
# obfuscation and prevents hackers from easily using a rainbow table for common password hashes)
# A rainbow table is a precomputed table for reversing cryptographic hash functions


# --- Security Key --- #
# Created using os.urandom
app.config['SECRET_KEY'] = """
    b'\xad\x15\x01\xd4J)z\xee\x99j\x91A-\xbf\xe1}f\x88\xd2+\xc5\xec6/\x0b\xd9\x0c\x97\xe6\xb9'\xbc''"""


# --- Connect database ---#
con = sqlite3.connect('database.db', check_same_thread=False)  # connect to the projects database
cur = con.cursor()  # Set cur to equal the database's cursor


# --- Schedules --- #
scheduler = BackgroundScheduler()  # Sets up the background scheduler


# --- Form models --- #
# No validation multiple select field fix
class NoValSelectMultipleField(SelectMultipleField):
    # Fix for a known fix with flask forms (The developers said they will fix the issue however
    # for the meantime use this method)
    def pre_validate(self, form):
        """per_validation is disabled"""


# Login form
class LoginForm(FlaskForm):
    # Username
    username = StringField('*Username: ', validators=[
        validators.DataRequired()
    ])
    # Password
    password = PasswordField('*Password: ', validators=[
        validators.DataRequired()
    ])
    # Submit button
    submit = SubmitField('Log In!')


# Sign up form
class SignUp(FlaskForm):
    # Username
    username = StringField('*Username: ', validators=[
        validators.DataRequired(),
        validators.Length(4, 12, "The username must be 4 characters min and 12 characters max")
    ])
    # Password with a confirmation password
    password = PasswordField('*Password: ', validators=[
        validators.DataRequired(),
        validators.Length(5, 64, "The password must be 5 characters min and 64 characters max"),
        validators.EqualTo('password_confirmation', message='Passwords must match')
    ])
    password_confirmation = PasswordField('*Repeat Password: ', validators=[
        validators.DataRequired(),
        validators.Length(5, 64, "The password must be 5 characters min and 64 characters max"),
        validators.EqualTo('password', message='Passwords must match')
    ])
    # Email has email validator and has a confirmation field
    email = EmailField('*Email: ', validators=[
        validators.DataRequired(),
        validators.Email(),
        validators.EqualTo('email_confirmation', message='Emails must match')
    ])
    email_confirmation = EmailField('*Repeat Email: ', validators=[
        validators.DataRequired(),
        validators.Email(),
        validators.EqualTo('email', message='Emails must match')
    ])
    # Submit button
    submit = SubmitField('Create an Account!')


# Create an Event
class CreateEvent(FlaskForm):
    # Title of the event
    title = StringField('Title of the event:', validators=[
        validators.DataRequired()
    ])
    # Description of the event
    description = StringField('Description of the event:', validators=[
        validators.DataRequired()
    ])
    # Categories of the questions in the event
    categories = NoValSelectMultipleField('Categories of the questions in the event:', validators=[], choices=[
        ('arts_and_literature', 'Arts & Literature'),
        ('film_and_tv', 'Film & TV'),
        ('food_and_drink', 'Food & Drink'),
        ('general_knowledge', 'General Knowledge'),
        ('geography', 'Geography'),
        ('history', 'History'),
        ('music', 'Music'),
        ('science', 'Science'),
        ('society_and_culture', 'Society & Culture'),
        ('sport_and_leisure', 'Sport & Leisure'),
        ('', 'Any')
    ])
    # Tags of the event
    tags = StringField('Tags of the event:', validators=[])
    # The difficulty of the questions in the event
    difficulty = SelectField('The difficulty of the questions in the event (can be left blank for any):', choices=[
        ('easy', 'Easy'),
        ('medium', 'Medium'),
        ('hard', 'Hard'),
        ('', 'Any')
    ])
    # The start time of the event
    start_time = DateTimeLocalField('The start time of the event:', format='%Y-%m-%dT%H:%M', validators=[
        validators.DataRequired()
    ])
    # The end of estimated end of the event
    end_time = DateTimeLocalField('The end of estimated end of the event (can be left blank if unsure):',
                                  format='%Y-%m-%dT%H:%M', validators=[])
    # Submit button
    submit = SubmitField('Create an Event!')


# Edit / view an Event
class EditEvent(FlaskForm):
    # Title of the event
    title = StringField('Title of the event:', validators=[
        validators.DataRequired()
    ])
    # Description of the event
    description = StringField('Description of the event:', validators=[
        validators.DataRequired()
    ])
    # Categories of the questions in the event
    categories = NoValSelectMultipleField('Categories of the questions in the event:', validators=[], choices=[
        ('arts_and_literature', 'Arts & Literature'),
        ('film_and_tv', 'Film & TV'),
        ('food_and_drink', 'Food & Drink'),
        ('general_knowledge', 'General Knowledge'),
        ('geography', 'Geography'),
        ('history', 'History'),
        ('music', 'Music'),
        ('science', 'Science'),
        ('society_and_culture', 'Society & Culture'),
        ('sport_and_leisure', 'Sport & Leisure'),
        ('', 'Any')
    ])
    # Tags of the event
    tags = StringField('Tags of the event:', validators=[])
    # The difficulty of the questions in the event
    difficulty = SelectField('The difficulty of the questions in the event (can be left blank for any):', choices=[
        ('easy', 'Easy'),
        ('medium', 'Medium'),
        ('hard', 'Hard'),
        ('', 'Any')
    ])
    # The start time of the event
    start_time = DateTimeLocalField('The start time of the event:', format='%Y-%m-%dT%H:%M', validators=[
        validators.DataRequired()
    ])
    # The end of estimated end of the event
    end_time = DateTimeLocalField('The end of estimated end of the event (can be left blank if unsure):',
                                  format='%Y-%m-%dT%H:%M', validators=[])
    # Submit button
    submit = SubmitField('Submit Changes!')


# --- Functions --- #
# Get json/data from API request
def getData(categories, limit, diff, tags):
    # Request, convert and return questions from the Quiz API
    success = False
    trys = 0
    while not success and trys < 3:
        try:
            # Create the request URL for the API
            request_URL = "https://the-trivia-api.com/api/questions?"
            if categories:
                request_URL += ('categories=' + categories)
            if limit:
                request_URL += ('&limit=' + limit)
            if diff:
                request_URL += ('&difficulty=' + diff)
            if tags:
                request_URL += ('&tags=' + tags)
            # Make request to the API URL
            request_data = requests.get(request_URL)
            # Convert page to readable json / dict format
            request_json = json.loads(request_data.text)
            # Set success to True
            success = True
            # return the json
            return request_json
        except Exception as e:  # If an error occurs print the error code and an error message.
            trys += 1
            print(e)
            print("Error: Could not request the API for questions attempt: " + str(trys))


# Save json/data from API request
def saveData(event_id, categories, limit, diff, tags):
    # Request, convert and return questions from the Quiz API
    success = False
    trys = 0
    while not success and trys < 3:
        try:
            # Create the request URL for the API
            request_URL = "https://the-trivia-api.com/api/questions?"
            if categories:
                request_URL += ('categories=' + categories)
            if limit:
                request_URL += ('&limit=' + limit)
            if diff:
                request_URL += ('&difficulty=' + diff)
            if tags:
                request_URL += ('&tags=' + tags)
            # Make request to the API URL
            request_data = requests.get(request_URL)
            # Convert page to readable json / dict format
            request_json = json.loads(request_data.text)
            # Insert or replace questions into the questions table
            sql_insert_questions = """
                                    INSERT OR REPLACE INTO questions (question_id, correct, incorrect)
                                    VALUES (?, ?, ?, ?, ?, ?, ?);"""
            # Execute SQL
            cur.execute(sql_insert_questions,
                        (request_json['id'], request_json['correct'], request_json['incorrect'],))
            # Commit changes to the questions table
            con.commit()
            # Set success to True
            success = True
        except Exception as e:  # If an error occurs print the error code and an error message.
            trys += 1
            print(e)
            print("Error: Could not request or insert/replace the questions from the API. Attempt: " + str(trys))


# Check answer
def checkAnswer(event_id, question_id, answer):
    print('test')


# Add a schedule job
def addSchedule(job_id, func, func_arg, date_time):
    # run_date='2009-11-06 16:30:05' 2022-07-06 12:37:00
    # Add a job to the schedular to run a function on a certain datetime
    scheduler.add_job(func, 'date', run_date=date_time, args=[func_arg], id=str(job_id))


# Get an event mostly used to check if an event exists and to get info for a particular event
def getEvent(event_id):
    # Get event
    sql_event = """
                        SELECT *
                        FROM events
                        WHERE event_id = ?;"""
    cur.execute(sql_event, (event_id,))
    result_event = cur.fetchall()
    # Return the results
    return result_event


# Get events used to get / search through all the events
def getEvents():
    sql_events = """
                        SELECT *
                        FROM events
                        ORDER BY start_time DESC;"""
    cur.execute(sql_events, )
    results_events = cur.fetchall()
    # Return the results
    return results_events


# End a game
def endGame(event_id):
    print('nothing', event_id)


# Start a game
def startGame(event_id):
    #
    result_event = getEvent(event_id)
    #
    sql_start_event = """
                            UPDATE events
                            SET active = ?
                            WHERE event_id = ?;"""
    cur.execute(sql_start_event, (1, event_id,))
    # Commit changes to the events table
    con.commit()
    #
    if scheduler.get_job(event_id) is not None:
        scheduler.remove_job(event_id)
    addSchedule(event_id, endGame, event_id, result_event[0][8])


# Create event used to create an event
def createEvent(title, description, categories, tags, difficulty, start_time, end_time):
    # Insert values into the events table
    print(title, description, (' '.join(categories)), tags, difficulty, start_time, end_time)
    sql_create_event = """
                        INSERT INTO events (title, description, categories, tags, difficulty, start_time, end_time)
                        VALUES (?, ?, ?, ?, ?, ?, ?);"""
    cur.execute(sql_create_event, (title, description, (' '.join(categories)), tags, difficulty, start_time, end_time,))
    # Commit changes to the events table
    con.commit()
    # Flash success message
    flash("Event successfully created!", 'message')
    # Get the event_id for the just submitted event
    event_id = cur.lastrowid
    print(event_id)
    # Add schedule for a quiz to start
    if scheduler.get_job(event_id) is not None:
        scheduler.remove_job(event_id)
    addSchedule(event_id, startGame, event_id, start_time)
    # Return the results
    return event_id


# Edit event used to edit an event
def editEvent(title, description, categories, tags, difficulty, start_time, end_time, event_id):
    # Update event
    sql_edit_event = """
                        UPDATE events
                        SET title = ?, description = ?, categories = ?, tags = ?, difficulty = ?, start_time = ?, 
                        end_time = ?
                        WHERE event_id = ?;"""
    cur.execute(sql_edit_event, (title, description, (' '.join(categories)), tags, difficulty, start_time, end_time,
                                 event_id,))
    # Commit changes to the events table
    con.commit()
    # Flash success message
    flash("Event successfully edited!", 'message')
    # Get the event_id for the just submitted event
    event_id = cur.lastrowid
    # Update schedule for a quiz to start
    if scheduler.get_job(event_id) is not None:
        scheduler.remove_job(event_id)
    addSchedule(event_id, startGame, event_id, start_time)
    # Return the results
    return event_id


# Delete event used to delete an event
def deleteEvent(event_id):
    # Delete event from the table
    sql_event_delete = """
                        DELETE FROM events
                        WHERE event_id = ?;"""
    cur.execute(sql_event_delete, (event_id,))
    # Commit changes to the events table
    con.commit()
    # Delete the start game schedule if it still exists
    if scheduler.get_job(event_id) is not None:
        scheduler.remove_job(event_id)
    # Flash success message
    flash('Event successfully deleted!', 'message')


# Get closet leaderboard around a user for an event
def getUserLeaderBoard(user_id, event_id):
    # Check users if the combination of username and password exists
    # Unfortunately in SQLite there is no great way of getting a limited amount of scores above and below a user
    # without putting a where in within a where in so a limit can be used
    sql_leaderboard = """
                        SELECT username, score
                        FROM users u, users_scores us
                        WHERE u.user_id IN (
                            SELECT user_id FROM users WHERE user_id IN (
                                SELECT user_id FROM users_scores WHERE event_id = ? AND score > (
                                    SELECT score FROM users_scores WHERE user_id = ?
                                ) 
                                LIMIT 4
                            )
                            UNION ALL
                            SELECT user_id FROM users WHERE user_id IN (
                                SELECT user_id FROM users_scores WHERE event_id = ? AND score < (
                                    SELECT score FROM users_scores WHERE user_id = ?
                                ) 
                                LIMIT 4
                            )
                            UNION ALL
                            SELECT user_id FROM users WHERE user_id = ?
                        )
                        ORDER BY score DESC;"""
    cur.execute(sql_leaderboard, (event_id, user_id, event_id, user_id, user_id,))
    result_leaderboard = cur.fetchall()
    # Check if user is even in the game
    if len(result_leaderboard) > 0:
        # Return the results
        return result_leaderboard
    else:
        # Return top 10 position if user isn't in the game
        return getTop10LeaderBoard(event_id)


# Get top 10 leaderboard for an event
def getTop10LeaderBoard(event_id):
    # Get top 10 users who scored highest from the table
    sql_leaderboard = """
                        SELECT u.username, us.score
                        FROM users u, users_scores us
                        WHERE u.user_id = us.user_id
                        AND us.event_id = ?
                        ORDER BY score DESC
                        LIMIT 10;"""
    cur.execute(sql_leaderboard, (event_id,))
    result_leaderboard = cur.fetchall()
    # return results
    return result_leaderboard


# Get sql users completed questions
def getUsersCompletedQuestions(user_id):
    # Get users completed questions from the table
    sql_users_comp_ques = """
                        SELECT question_id
                        FROM users_comp_ques
                        WHERE user_id = ?;"""
    cur.execute(sql_users_comp_ques, (user_id,))
    results_users_comp_ques = cur.fetchall()
    # Return the results
    return results_users_comp_ques


# Award the user points for the question and mark the question as completed in the database for the user
def awardUser(user_id, event_id, question_id, difficulty, incorrect_answers):
    if difficulty == 'hard':
        diff = 2
    elif difficulty == 'medium':
        diff = 1.5
    else:
        diff = 1
    awarded_score = round((100 * diff) - incorrect_answers * 50)
    # easy question = 100
    # medium question = 150
    # hard question = 200
    # every wrong answer takes 50 points
    #
    # Get users previous score if they had one
    sql_users_score = """
                            SELECT score
                            FROM users_scores
                            WHERE user_id = ?
                            AND event_id = ?;"""
    cur.execute(sql_users_score, (user_id, event_id,))
    result_users_score = cur.fetchone()
    # If the user doesn't have a score set their score to 0
    if not result_users_score:
        result_users_score = 0
    # Award user points
    sql_assign_score = """
                            INSERT OR REPLACE INTO users_scores(event_id, user_id, score) 
                            VALUES (?,?,?);"""
    cur.execute(sql_assign_score, (event_id, user_id, (result_users_score[0] + awarded_score),))
    # Commit changes to the table
    con.commit()
    print('Award: ', str(user_id) + ', ' + str(awarded_score) + ' Points.')
    # Assign the user completed question to the users_comp_ques table
    sql_assign_question = """
                            INSERT OR REPLACE INTO users_comp_ques(user_id, question_id, date_comp, incorrect_answers) 
                            VALUES (?,?,?,?);"""
    cur.execute(sql_assign_question, (user_id, question_id, datetime.now(), incorrect_answers,))
    # Commit changes to the table
    con.commit()
    print('Assigned user: ' + str(user_id) + ' with the question: ' + str(question_id))


# loginReturn handles the login form and system on the login page
def loginReturn(form):
    if form.validate_on_submit():
        # Set email and password variables
        un = form.username.data
        pw = form.password.data
        # Check users if the combination of username and password exists
        sql_user = """
                        select *
                        from users 
                        where username = ?;"""
        cur.execute(sql_user, (un,))
        result_user = cur.fetchall()
        # If a user with that username and password combination exists set session values with the users data
        if len(result_user) == 1 and bcrypt.check_password_hash(result_user[0][2], pw):
            flash(str(result_user[0][1]) + " has successfully logged in!", 'message')
            session['user_id'] = result_user[0][0]
            session['username'] = result_user[0][1]
            session['security'] = result_user[0][4]
        else:
            flash("Username or password incorrect!", 'error')
    else:
        flash("There is something missing!", 'error')


# signupReturn handles the signup form and system on the signup page
def signupReturn(form):
    if form.validate_on_submit():
        # Set username, password and email variables
        un = form.username.data
        em = form.email.data
        pw = form.password.data
        # Encrypt Password
        pw_hash = bcrypt.generate_password_hash(pw, bcrypt_level)
        # Encrypt Email
        em_hash = bcrypt.generate_password_hash(em, bcrypt_level)
        try:
            # Check users if the email already exists
            sql_user = """
                            select *
                            from users
                            where username = ?;"""
            cur.execute(sql_user, (un,))
            if len(cur.fetchall()) >= 1:
                # If an account already exists with the inputted username flash an error
                flash("An account with that username already exists!", 'error')
                return None
            try:
                # Insert new user into database with encrypted password and email
                cur.execute("INSERT INTO users(username,password,email) VALUES (?,?,?)", (un, pw_hash, em_hash,))
                con.commit()
                # Flash success message
                flash(un + " has successfully created an account!", 'message')
                # Attempt login
                loginReturn(form)
            except Exception as e:  # If an error occurs print the error code and an error message.
                print(e)
                print("Error: Could not upload account to database!", 'error')
                # Flash error message
                flash("An error occurred and the account could not be created! Please try again later.", 'error')
        except Exception as e:  # If an error occurs print the error code and an error message.
            print(e)
            print("Error: Account already existed!")
            # Flash error message
            flash("Please try again.", 'error')
    else:
        flash("There is something missing!", 'error')


# --- Routes --- #
# Main page
@app.route('/', methods=['GET'])
@app.route('/index', methods=['GET'])
def index():
    events = getEvents()
    # Render the page
    return render_template('index.html', title='Index', events=events)


# API
@app.route('/api', methods=['GET', 'POST'])
def api():
    if request.method == 'POST':
        response_json = request.get_json()
        awardUser(session.get('user_id'), response_json['event'], response_json['id'], response_json['diff'],
                  response_json['inc'])
        return '', 200
    else:
        if request.args.get('id'):
            # Set the id parameter to a variable
            event_id = request.args.get('id')
            # Get the event with the parameter id
            result_event = getEvent(event_id)
            # Check if event_id is valid
            if len(result_event) > 0:
                # Return leader board for event
                leaderboard = {'data': getTop10LeaderBoard(result_event[0][0])}
                return leaderboard
            else:
                # Else an event could not be found so flash a message to the user and return them to the index page
                flash("An event with that id was not found!", 'error')
                return redirect(url_for('index'))
        else:
            # If the user trys to request the page without the id get variable flash them a message and redirect them
            flash("You have to have select an event to be able to access that page!", 'error')
            return redirect(url_for('index'))


# Login page has the login form for users to access their existing account
@app.route('/account/login', methods=['GET', 'POST'])
def login():
    # If user is already logged in flash a message and redirect them back to the index page
    if session.get('user_id'):
        flash("You are already logged in!", 'error')
        return redirect(url_for('index'))

    # Set Login Form
    loginform = LoginForm()

    # If the page request method is POST
    if request.method == 'POST':
        # Contacts the loginReturn function which will check if the user exists and logs in and or return a msg
        loginReturn(loginform)
        return redirect(url_for('index'))

    return render_template('login.html', title='Login!', form=loginform)


# Signup page has the sign-up form for users to create an account
@app.route('/account/signup', methods=['GET', 'POST'])
def signup():
    # If user is already logged in flash a message and redirect them back to the index page
    if session.get('user_id'):
        flash("You are already logged in!", 'error')
        return redirect(url_for('index'))

    # Set SignUp Form
    signupform = SignUp()

    # If the page request method is POST
    if request.method == 'POST':
        # Contacts the signupReturn function which will check the data returned and create an account and or
        # return a flash msg
        signupReturn(signupform)
    return render_template('signup.html', title='Create an account!', form=signupform)


# Logout page logs out the user and redirect the user back to the index page
@app.route('/account/logout', methods=['GET'])
def logout():
    # clear out the session
    if session.get('user_id'):
        session['user_id'] = None
        session['username'] = None
        session['security'] = None
        flash("You have successfully logged out", 'message')
    else:
        flash("You have to be logged in to do that!", 'error')
    return redirect(url_for('index'))


# Event creation page used by staff to create events
@app.route('/event/create', methods=['GET', 'POST'])
def eventCreate():
    # set from to equal the create event from
    form = CreateEvent()
    # check if the user is staff
    if session.get('security') == 'staff':
        # check if the request is POST
        if request.method == 'POST':
            # if the form is valid
            print(form.errors)
            if form.validate_on_submit():
                # Form vars
                title = form.title.data
                description = form.description.data
                categories = form.categories.data
                tags = form.tags.data
                difficulty = form.difficulty.data
                start_time = form.start_time.data
                end_time = form.end_time.data
                # Create the event and return the newly created events id
                event_id = createEvent(title, description, categories, tags, difficulty, start_time, end_time)
                # redirect the page to the view event page with the new id
                return redirect(url_for('eventView', id=event_id))
            else:
                print(form.errors)
                # The form was invalid inform the user
                flash("There is something missing or something is invalid!", 'error')
        # render the page if the request was a get method
        return render_template('create.html', title='Create New Event', form=form)
    else:
        # Only staff are allowed to create events so redirect anyone who isn't a staff member and inform them
        flash("You have to be logged in as staff to access that page!", 'error')
        return redirect(url_for('index'))


# Event edit page used by staff to edit events
@app.route('/event/edit', methods=['GET', 'POST'])
def eventEdit():
    # set from to equal the create event from
    form = EditEvent()
    # check if the user is staff
    if session.get('security') == 'staff':
        # If a request was made with an id parameter
        if request.args.get('id'):
            # set the id parameter to a variable to be checked
            event_id = request.args.get('id')
            # Get event with the id parameter
            result_event = getEvent(event_id)
            # Check if event_id is valid
            if len(result_event) > 0:
                # If the request method was POST
                if request.method == 'POST':
                    if request.form.get('delete_btn') == 'delete':
                        # delete the event
                        deleteEvent(event_id)
                        return redirect(url_for('index'))
                    # If the form is valid on submit
                    if form.validate_on_submit():
                        # Set form vars
                        title = form.title.data
                        description = form.description.data
                        categories = form.categories.data
                        tags = form.tags.data
                        difficulty = form.difficulty.data
                        start_time = form.start_time.data
                        end_time = form.end_time.data
                        # Edit the event
                        editEvent(title, description, categories, tags, difficulty, start_time, end_time, event_id)
                        # redirect the page back to the view page for the event
                        return redirect(url_for('eventView', id=event_id))
                    else:
                        # The form was invalid inform the user
                        flash("There is something missing or something is invalid!", 'error')
                # Render the edit page if the request method was GET
                return render_template('edit.html', title='Edit: ' + str(result_event[0][1]), form=form,
                                       result_event=result_event[0])
            else:
                # Else an event could not be found
                flash("Could not find an event with that ID!", 'error')
                return redirect(url_for('index'))
        else:
            # No id parameter was passed inform the user
            flash("You have to have select an event to be able to access that page!", 'error')
            return redirect(url_for('index'))
    else:
        # Only staff are allowed to create events so redirect anyone who isn't a staff member and inform them
        flash("You have to be logged in as staff to access that page!", 'error')
        return redirect(url_for('index'))


# Event view page to view more detailed information on the event and to click or wait to click the play button
@app.route('/event/view', methods=['GET'])
def eventView():
    # If a request was made with an id parameter
    if request.args.get('id'):
        # Set the id parameter to a variable
        event_id = request.args.get('id')
        # Get the event with the parameter id
        result_event = getEvent(event_id)
        # Check if event_id is valid
        if len(result_event) > 0:
            # Get top 10 users in leaderboard
            leaderboard = getTop10LeaderBoard(event_id)
            # Get users position in leaderboard
            userboard = getUserLeaderBoard(session.get('user_id'), event_id)
            # Render html
            return render_template('view.html', title=str(result_event[0][1]), result_event=result_event[0],
                                   leaderboard=leaderboard, userboard=userboard)
        else:
            # Else an event could not be found so flash a message to the user and return them to the index page
            flash("An event with that id was not found!", 'error')
            return redirect(url_for('index'))
    else:
        # If the user trys to request the page without the id get variable flash them a message and redirect them
        flash("You have to have select an event to be able to access that page!", 'error')
        return redirect(url_for('index'))


# Quiz page
@app.route('/event/play', methods=['GET'])
def eventPlay():
    if session.get('user_id'):
        # If a request was made with an id parameter
        if request.args.get('id'):
            # Set the id parameter to a variable
            event_id = request.args.get('id')
            # Get the event with the parameter id
            result_event = getEvent(event_id)
            # Check if event_id is valid
            if len(result_event) > 0:
                if result_event[0][8]:
                    # Get users completed questions
                    result_comp = getUsersCompletedQuestions(session.get('user_id'))
                    # Render html
                    return render_template('play.html', title=str(result_event[0][1]), result_event=result_event[0],
                                           result_comp=result_comp)
                else:
                    # The event hasn't started or has already finished
                    flash("This event hasn't started yet or has already ended!", 'error')
                    return redirect(url_for('eventView', id=event_id))
            else:
                # Else an event could not be found so flash a message to the user and return them to the index page
                flash("An event with that id was not found!", 'error')
                return redirect(url_for('index'))
        else:
            # If the user trys to request the page without the id get variable flash them a message and redirect them
            flash("You have to have select an event to be able to access that page!", 'error')
            return redirect(url_for('index'))
    else:
        # If the user isn't logged in
        flash("You have to be logged in for that!", 'error')
        return redirect(url_for('index'))


# Quiz page 2 testing
@app.route('/event/play2', methods=['GET','POST'])
def eventPlay2():
    # If a request was made with an id parameter
    if request.args.get('id'):
        # Set the id parameter to a variable
        event_id = request.args.get('id')
        # Get the event with the parameter id
        result_event = getEvent(event_id)
        # Check if event_id is valid
        if len(result_event) > 0:
            if result_event[0][8]:
                # Get questions
                # Render html
                return render_template('play2.html', title=str(result_event[0][1]), result_event=result_event[0])
            else:
                # The event hasn't started or has already finished
                flash("This event hasn't started yet or has already ended!", 'error')
                return redirect(url_for('eventView', id=event_id))
        else:
            # Else an event could not be found so flash a message to the user and return them to the index page
            flash("An event with that id was not found!", 'error')
            return redirect(url_for('index'))
    else:
        # If the user trys to request the page without the id get variable flash them a message and redirect them
        flash("You have to have select an event to be able to access that page!", 'error')
        return redirect(url_for('index'))


# Redirect most common error pages
@app.errorhandler(404)
@app.errorhandler(403)
@app.errorhandler(410)
@app.errorhandler(500)
def page_not_found(err):
    # If the user reaches a 404, 403, 410 or 500 error or common errors redirect them back to the index and inform them
    flash("Whoops, " + str(err), 'error')
    return redirect(url_for('index'))


# --- Website Startup --- #
if __name__ == '__main__':
    # Start the scheduler
    scheduler.start()  # Starts the schedules
    atexit.register(lambda: scheduler.shutdown())  # Sets up the schedular to shut down when the app is exited
    # Start The Web App
    port = 7250  # Port to be hosted on
    app.run('', port, debug=True)  # Run the app with debug mode on
