# --- Import Libraries --- #
# Flask Libraries (used to run the actual website)
from flask import Flask, render_template, request, redirect, flash, session, url_for  # General Flask
from flask_wtf import FlaskForm  # For Flask forms
from flask_bcrypt import Bcrypt  # For encryption
# WTForms Libraries (used for the websites forms)
from wtforms import StringField, SubmitField, EmailField, PasswordField, validators
# Miscellaneous Libraries
import sqlite3  # To connect and run query's for the database
import requests  # To request and download data from APIs
import json  # Required to be able to view and manage the json files and format
from apscheduler.schedulers.background import \
    BackgroundScheduler  # Used to run the get data and clear data functions every 30 minutes
import atexit  # Used for scheduler to shut down the schedules when the app is exited
from datetime import datetime, date, timedelta  # For getting the current or future datetime

# TODO
#   Get request once through python instead of javascript that way the limit isn't reached if all the users are on the
#   same network
#   Add better password complexity check
#   Add better data security
#   If I make the requests within javascript the client would be calling the API meaning the server side doesnt have to
#   -worry about request limits although if the user is technical they could dig up the answers although I can make this
#   -really hard to do
#   Mention that I'm using code from IA2
#   Daily quiz is handled by flask with an javascript countdown
#   Quizzes are generated by javascript but is handed get info and users completed questions
#   The quizzes are entirely generated by javascript?
#   What if the API doesn't respond set a fallback option or error message to retry
#   Daily question was disabled


# --- Assign flask app --- #
app = Flask(__name__)

# --- Assign Bcrypt --- #
bcrypt = Bcrypt(app)

# --- Security Key --- #
app.config['SECRET_KEY'] = """
    b'\xad\x15\x01\xd4J)z\xee\x99j\x91A-\xbf\xe1}f\x88\xd2+\xc5\xec6/\x0b\xd9\x0c\x97\xe6\xb9'\xbc''"""
# Created using os.urandom


# --- Connect database ---#
con = sqlite3.connect('database.db', check_same_thread=False)  # connect to the projects database
cur = con.cursor()  # Set cur to equal the database's cursor


# --- Form models --- #
# Login form
class LoginForm(FlaskForm):
    # Username
    username = StringField('*Username: ', validators=[
        validators.DataRequired()])

    # Password
    password = PasswordField('*Password: ', validators=[
        validators.DataRequired()])

    # Login form with a submit button which isn't required but added for user ability
    submit = SubmitField('Log In!')


# Sign up form
class SignUp(FlaskForm):
    # Username
    username = StringField('*Username: ', validators=[
        validators.DataRequired(),
        validators.Length(3, 12, "The username must be 3 characters min and 12 characters max")])

    # Password with a confirmation password
    password = PasswordField('*Password: ', validators=[
        validators.DataRequired(),
        validators.Length(3, 64, "The password must be 3 characters min and 64 characters max"),
        validators.EqualTo('password_confirmation', message='Passwords must match')])

    password_confirmation = PasswordField('*Repeat Password: ', validators=[
        validators.DataRequired(),
        validators.Length(3, 64, "The password must be 3 characters min and 64 characters max"),
        validators.EqualTo('password', message='Passwords must match')])

    # Email has email validator and has a confirmation field
    email = EmailField('*Email: ', validators=[
        validators.DataRequired(),
        validators.Email(),
        validators.EqualTo('email_confirmation', message='Emails must match')])

    email_confirmation = EmailField('*Repeat Email: ', validators=[
        validators.DataRequired(),
        validators.Email(),
        validators.EqualTo('email', message='Emails must match')])

    # Sign up form with a submit button which isn't required but added for user ability
    submit = SubmitField('Create an Account!')


# --- Functions --- #
# Get data for daily question
# def getDailyQuestion():
#     # SQL set database question
#     global dailyQuestion
#     global dailyQuestionAnswer
#     dailyQuestion = {
#         "question": "Which country's flag can be described as 'Red with a green five-pointed star in the center.'?",
#         "answers": ["Iraq", "Kazakhstan", "Czechia", "Morocco"]}
#     dailyQuestionAnswer = {"Morocco"}
# getDailyQuestion()
#
#
# def get2DailyQuestion(answer):
#     # SQL get database question
#     if session.get('user_id'):
#         if answer:
#             if answer == dailyQuestionAnswer:
#                 question = {"question": "Correct!", "answers": [""]}
#             else:
#                 question = {"question": "Incorrect!", "answers": [""]}
#         else:
#             question = dailyQuestion
#
#         return question
#     else:
#         return {"question": "Log in to compete in the daily question!", "answers": [""]}


# Get sql users completed questions


# Get user leaderboard
def getUserLeaderBoard(user):
    # Check users if the combination of username and password exists
    # Unfortunately in SQLite there is no great way of getting a limited amount of scores above and below a user
    # without putting a where in within a where in so a limit can be used
    sql_leaderboard = """
                    SELECT username, score, icon
                    FROM users
                    WHERE user_id IN (
                        SELECT user_id FROM users WHERE user_id IN (
                            SELECT user_id FROM users WHERE score > (
                                SELECT score FROM users WHERE user_id = ?
                            ) 
                            LIMIT 4
                        )
                        UNION ALL
                        SELECT user_id FROM users WHERE user_id IN (
                            SELECT user_id FROM users WHERE score < (
                                SELECT score FROM users WHERE user_id = ?
                            ) 
                            LIMIT 4
                        )
                        UNION ALL
                        SELECT user_id FROM users WHERE user_id = ?
                    )
                    ORDER BY score DESC;"""
    cur.execute(sql_leaderboard, (user, user, user,))
    result_leaderboard = cur.fetchall()
    return result_leaderboard


# fuck
def getTop10LeaderBoard():
    sql_leaderboard = """
                            SELECT username, score, icon
                            FROM users
                            ORDER BY score DESC
                            LIMIT 10;"""
    cur.execute(sql_leaderboard, )
    result_leaderboard = cur.fetchall()
    return result_leaderboard


# loginReturn handles the login form and system on every page of the website
def loginReturn(form):
    if form.validate_on_submit():
        # Set email and password variables
        un = form.username.data
        pw = form.password.data

        # Check users if the combination of username and password exists
        sql_user = """
                        select *
                        from users 
                        where username = ?;"""
        cur.execute(sql_user, (un,))
        result_user = cur.fetchall()

        # If a user with that username and password combination exists set session values with the users data
        if len(result_user) == 1 and bcrypt.check_password_hash(result_user[0][2], pw):
            flash(str(result_user[0][1]) + " has successfully logged in!", 'message')
            session['user_id'] = result_user[0][0]
            session['username'] = result_user[0][1]
        else:
            flash("Username or password incorrect!", 'error')
    else:
        flash("There is something missing!", 'error')


# signupReturn handles the signup form and system on the signup page
def signupReturn(form):
    if form.validate_on_submit():
        # Set username, password and email variables
        un = form.username.data
        em = form.email.data
        pw = form.password.data

        # Encrypt Password
        pw_hash = bcrypt.generate_password_hash(pw)
        # Encrypt Email
        em_hash = bcrypt.generate_password_hash(em)

        try:
            # Check users if the email already exists
            sql_user = """
                            select *
                            from users
                            where username = ?;"""
            cur.execute(sql_user, (un,))
            if len(cur.fetchall()) >= 1:
                # If an account already exists with the inputted username flash an error
                flash("An account with that username already exists!", 'error')
                return None

            # Check users if the email already exists
            # No longer WORKS due to email being encrypted FIX THIS!!!
            sql_user = """
                            select *
                            from users
                            where email = ?;"""
            cur.execute(sql_user, (em_hash,))
            if len(cur.fetchall()) >= 1:
                # If an account already exists with the inputted email flash an error
                flash("An account with that email already exists!", 'error')
                return None

            try:
                # Insert new user into database with encrypted password and email
                cur.execute("INSERT INTO users(username,password,email) VALUES (?,?,?)", (un, pw_hash, em_hash,))
                con.commit()

                # Flash success message
                flash(un + " has successfully created an account!", 'message')

                # Attempt login
                loginReturn(form)
            except Exception as e:  # If an error occurs print the error code and an error message.
                print(e)
                print("Error: Could not upload account to database!", 'error')
                # Flash error message
                flash("An error occurred and the account could not be created! Please try again later.", 'error')
        except Exception as e:  # If an error occurs print the error code and an error message.
            print(e)
            print("Error: Account already existed!")
            # Flash error message
            flash("Please try again.", 'error')
    else:
        flash("There is something missing!", 'error')


# --- Schedules --- #
# schedule_0 = BackgroundScheduler()  # Sets up the background scheduler
# schedule_0.add_job(getDailyQuestion, 'cron', hour=23, timezone="UTC")  # Sets getData function to run every day at 11pm
# schedule_0.start()  # Starts the schedules
# atexit.register(lambda: schedule_0.shutdown())  # Sets up the schedular to shut down when the app is exited


# --- Routes --- #
# Main page contains the map and relate information and links to the rest of the site
@app.route('/', methods=['GET', 'POST'])
@app.route('/index', methods=['GET', 'POST'])
def index():
    # Render the page
    return render_template('index.html', title='Index')  # , dailyQuestion=dailyQuestion)


# Login page has the login form for users to access their existing account
@app.route('/login', methods=['GET', 'POST'])
def login():
    # If user is already logged in flash a message and redirect them back to the index page
    if session.get('user_id'):
        flash("You are already logged in!", 'error')
        return redirect(url_for('index'))

    # Set Login Form
    loginform = LoginForm()

    # If the page request method is POST
    if request.method == 'POST':
        # Contacts the loginReturn function which will check if the user exists and logs in and or return a flash msg
        loginReturn(loginform)

    return render_template('login.html', title='Login!', form=loginform)


# Signup page has the sign-up form for users to create an account
@app.route('/signup', methods=['GET', 'POST'])
def signup():
    # If user is already logged in flash a message and redirect them back to the index page
    if session.get('user_id'):
        flash("You are already logged in!", 'error')
        return redirect(url_for('index'))

    # Set SignUp Form
    signup_form = SignUp()
    # Set Login Form
    login_form = LoginForm()

    # If the page request method is POST
    if request.method == 'POST':
        if signup_form.validate():
            # Contacts the signupReturn function which will check the data returned and create an account and or
            # return a flash msg
            signupReturn(signup_form)
        elif login_form.validate():
            # Contacts the loginReturn function which will check if the user exists and logs in and or return a flash
            # msg
            print('f')
            # loginReturn(login_form)

    return render_template('signup.html', title='Create an account!', loginform=login_form, form=signup_form)


# Logout page logsout the user and redirect the user back to the index page
@app.route('/logout', methods=['GET'])
def logout():
    # clear out the session
    if session.get('user_id'):
        session['user_id'] = None
        session['username'] = None
        flash("You have successfully logged out", 'message')
    else:
        flash("You have to be logged in to do that!", 'error')
    return redirect(url_for('index'))


# API
@app.route('/api', methods=['POST'])
def api():
    if request.method == 'POST':
        response_json = request.get_json()
        print(response_json['id'], response_json['diff'], response_json['inc'])
        return '', 200


# Quizzes page created to search through quiz topics and select a quiz topic you would like to play and its difficulty.
@app.route('/signup', methods=['GET', 'POST'])
def quizzes():
    return render_template('quizzes.html', title='Quizzes!')


# Quiz page
@app.route('/quiz', methods=['GET', 'POST'])
def quiz():
    return render_template('quiz.html', title='Quiz!')


# User page contains relvent infromation to the user and the ability to change email, password or delete the account
@app.route('/user', methods=['GET', 'POST'])
def user():
    # Wasn't added due to time constraints but would have included an ability to change the users email or password
    return render_template('user.html', title='User Settings!')


# Redirect most common error pages
@app.errorhandler(404)
@app.errorhandler(403)
@app.errorhandler(410)
@app.errorhandler(500)
def page_not_found(err):
    flash("Whoops, " + str(err), 'error')
    return redirect(url_for('index'))


# --- Website Startup --- #
if __name__ == '__main__':
    # Start App
    port = 7250  # Port to be hosted on
    app.run('', port, debug=True)  # Run the app
